#!/usr/bin/perl -w
#
# xenum-inject - a utility to replace the main XENUM4_DECLARE() and XENUM_DEFINE()
# with they content that they generate, for inspecting the generated code, and
# running documentation generation (doxygen) on it.
#
# Copyright 2018 Simon Lodal <simonl@parknet.dk>
# 

use strict;



######################################## ARGUMENT VALUES #########################################
# General argument values
my $compiler = "";
my $inputFileName = "";
my $outputFileName = "";
my $includeDirs = [];


########################################## RUNTIME DATA ##########################################
my $appname = "xenum4-inject";
my $filename = "xenum4-inject";
my $appversion = "0.1";

# If no xenum main macros were found in the input, there is no reason to preprocess it.
my $doPreProcess = 0;
my $defaultIncludeDirs = [
	"xenum/test/inc/",
	"xenum/lib/inc/",
];

# Array of output parts. Each field is an object containing:
# - inputText : The raw input text leading up to an xenum main macro (or EOF).
# - macro: Which main macro was found after inputText; "declare", "define", or empty (EOF).
# - suffix: The suffix defined as macro parameter.
# - generated: The code text generated by the macro.
my $output = [];



######################################### INPUT HANDLING #########################################

sub showHelp($)
{
	my ($errmsg) = @_;

	print(STDERR "${errmsg}\n\n") if ($errmsg);

	print <<HELP
$appname-$appversion

Replace the main XENUM4_DECLARE() and XENUM4_DEFINE() macros with the content they generate,
so you can inspect what is generated, and run automated code documentation generation on the
result.

Usage:
$filename [options]

General options:
    -c, --compiler BINARYNAME Name (or path) to compiler to use for preprocessing. If not
                              defined, 'g++' is used.
    -i, --input FILENAME      Input file to process. Can be a header or source file.
    -I, --include PATH        Include path to add to the preprocessor command line.
    -o, --output FILENAME     Output file. Optional, writes to stdout if not defined.

HELP
;
	exit 1;
}


sub show_version()
{
	print("$appname-$appversion\n");
	exit(1);
}


sub parseArgs()
{
	my ($argc, $aidx, $arg, $val);

	$argc = @ARGV;

	showHelp("") unless ($argc > 0);
	for ($aidx=0; $aidx<$argc; $aidx++) {
		$arg = $ARGV[$aidx];
		if ($arg =~ /^(?:-c|--compiler)$/) {
			showHelp("Error: Value missing after $arg") if ($aidx == ($argc-1));
			$compiler = $ARGV[++$aidx];
			next;
		}
		if ($arg =~ /^(?:-i|--input)$/) {
			showHelp("Error: Value missing after $arg") if ($aidx == ($argc-1));
			$inputFileName = $ARGV[++$aidx];
			next;
		}
		if ($arg =~ /^(?:-I|--include)$/) {
			showHelp("Error: Value missing after $arg") if ($aidx == ($argc-1));
			push(@{$includeDirs}, $ARGV[++$aidx]);
			next;
		}
		if ($arg =~ /^(?:-o|--output)$/) {
			showHelp("Error: Value missing after $arg") if ($aidx == ($argc-1));
			$outputFileName = $ARGV[++$aidx];
			next;
		}

		showHelp("error: unknown argument '$arg'");
	}

	if ($inputFileName eq "") {
		showHelp("Error: Input filename missing (-i).");
	}
	if ($compiler eq "") {
		$compiler = "g++";
	}
}


########################################## PARSE INPUTS ##########################################

sub addOutputPart($$$)
{
	my ($inputText, $macro, $suffix) = @_;
	#print("addOutputPart() macro='${macro}' suffix='${suffix}' inputText(".length($inputText)."):\n".("-"x60)."\n".$inputText."\n".("-"x60)."\n");
	#print("addOutputPart() macro='${macro}' suffix='${suffix}' inputText(".length($inputText).")\n");
	my $outputPart = {
		inputText => $inputText,
		macro => $macro,
		suffix => $suffix,
		generated => "",
	};
	push(@{$output}, $outputPart);
}


sub parseRawInput()
{
	my ($rawLines, $rawIndex, $rawLine);
	my ($preInput, $remLine, $macro, $suffix);
	open(RAWINPUT, "<${inputFileName}")
		|| die("ERROR: Could not open input file '${inputFileName}'.\n");
	@{$rawLines} = <RAWINPUT>;
	close(RAWINPUT);
	#print("parseRawInput() rawLines:".@{$rawLines}."\n");

	$preInput = "";
	for ($rawIndex=0; $rawIndex<@{$rawLines}; $rawIndex++) {
		$rawLine = $rawLines->[$rawIndex];
		while ($rawLine =~ /^(.*?)(?:XENUM4_(DECLARE|DEFINE))(.*)/o) {
			$preInput .= $1;
			$macro = lc($2);
			$remLine = $3;
			# FIXME: Multiline parsing?
			if ($remLine =~ /^\s*\(\s*([^\s]+)\s*\)(.*)/) {
				($suffix, $remLine) = ($1, $2);
			}
			else {
				die("ERROR: Could not parse suffix parameter: ${remLine}\n");
			}
			#print("parseRawInput() macro='${macro}' suffix='${suffix}'\n");
			addOutputPart($preInput, $macro, $suffix);
			$preInput = "";
			$rawLine = $remLine;
		}
		$preInput .= $rawLine;
	}

	if (@{$output} != 0) {
		$doPreProcess = 1;
	}
	# Always add EOF part even if empty.
	addOutputPart($preInput, "", "");
}


sub parsePreProcessed()
{
	my ($cmd, $ppLines, $ppIndex, $ppLine);
	my ($generated, $remLine, $macro, $mark, $suffix);
	my ($curMacro, $curSuffix, $outputIndex, $outputPart);

	$cmd = "${compiler} -E -x c++ -std=c++11 -P -DXENUM4_DEBUG_PP=1" .
		" ".join(" ", map {"-I $_"} @{$includeDirs}).
		" ".join(" ", map {"-I $_"} @{$defaultIncludeDirs}).
		" ".$inputFileName;
	#print("preProcess() cmd: '${cmd}'\n");
	open(PPINPUT, "${cmd} |")
		|| die("ERROR: Could not execute preprocessor: ${cmd}\n");
	@{$ppLines} = <PPINPUT>;
	close(PPINPUT);

	$outputIndex = 0;
	$outputPart = $output->[$outputIndex];

	#print("preProcess() got preprocessed, ppLines:".@{$ppLines}."\n");
	$generated = "";
	$curSuffix = "";
	for ($ppIndex=0; $ppIndex<@{$ppLines}; $ppIndex++) {
		$ppLine = $ppLines->[$ppIndex];
		while ($ppLine =~ /^(.*?)\@XENUM4-MARK:([^\s@]+) ([^\s@]+) ([^\s@]+)\@(.*)/o) {
			$generated .= $1;
			($macro, $mark, $suffix, $remLine) = ($2, $3, $4, $5);
			if (!($macro && $mark && $suffix)) {
				die("BUG: Invalid marker (empty field): ${macro} ${mark} ${suffix}\n");
			}
			if ($curSuffix eq "") {
				if ($mark ne "begin") {
					die("BUG: Expected a 'begin' marker, found: ${macro} ${mark} ${suffix}\n");
				}
				$curMacro = $macro;
				$curSuffix = $suffix;
				$generated = "";
			}
			else {
				if (($macro ne $curMacro) ||
				    ($mark ne "end") ||
				    ($suffix ne $curSuffix)) {
					die("BUG: Expected marker '${curMacro} end ${curSuffix}', found: ${macro} ${mark} ${suffix}\n");
				}
				if (($macro eq $outputPart->{macro}) && ($suffix eq $outputPart->{suffix})) {
					$outputPart->{generated} = $generated;
					$outputIndex++;
					$outputPart = $output->[$outputIndex];
				}
				$curSuffix = "";
			}
			$ppLine = $remLine;
		}
		$generated .= $ppLine;
	}

	if ($curSuffix ne "") {
		die("BUG: End marker not found for macro='${curMacro} and suffix='${curSuffix}'.\n");
	}
	if ($outputIndex != (@{$output} - 1)) {
		die("BUG: Did not find preprocessed section '$outputPart->{macro}':'$outputPart->{suffix}'.\n");
	}
}


########################################## WRITE OUTPUT ##########################################

sub formatGenerated($)
{
	my ($generated) = @_;
	my $line;
	my $out = [];

	foreach $line (split(/\@XENUM4-NWLN\@/, $generated)) {
		$line =~ s/\@XENUM4-IND:1\@/\t/g;
		$line =~ s/\@XENUM4-IND:2\@/\t\t/g;
		$line =~ s/\@XENUM4-IND:3\@/\t\t\t/g;
		$line =~ s/\@XENUM4-IND:4\@/\t\t\t\t/g;
		$line =~ s/^[ *]//;
		$line =~ s/^[\s]*$//;
		if ($line) {
			push(@{$out}, $line);
		}
	}
	return join("\n", @{$out});
}


sub writeOutput()
{
	my ($outputPart);
	my $out = [];

	foreach $outputPart (@{$output}) {
		push(@{$out}, $outputPart->{inputText});
		push(@{$out}, formatGenerated($outputPart->{generated}));
	}

	if ($outputFileName eq "") {
		print(join("", @{$out}));
	}
	else {
		open(OUTPUT, ">${outputFileName}")
			|| die("ERROR: Could not open output file '${outputFileName}'.\n");
		print(OUTPUT join("", @{$out}));
		close(OUTPUT);
	}
}


############################################# main() #############################################
sub main()
{
	parseArgs();
	parseRawInput();
	if ($doPreProcess) {
		parsePreProcessed();
	}
	writeOutput();
}


main();
