#!/usr/bin/perl -w
#
# xenum-inject - a utility to replace the main XENUM4_DECLARE() and XENUM_DEFINE()
# with they content that they generate, for inspecting the generated code, and
# running documentation generation (doxygen) on it.
#
# Copyright 2018 Simon Lodal <simonl@parknet.dk>
# 

use strict;



######################################## ARGUMENT VALUES #########################################
# General argument values
my $compiler = "";
my $inputFileName = "";
my $outputFileName = "";



########################################## RUNTIME DATA ##########################################
my $appname = "xenum4-inject";
my $filename = "xenum4-inject";
my $appversion = "0.1";

# If no xenum main macros were found in the input, there is no reason to preprocess it.
my $doPreProcess = 0;

# Array of output parts. Each field is an object containing:
# - inputText : The raw input text leading up to an xenum main macro (or EOF).
# - macro: Which main macro was found after inputText; "declare", "define", or empty (EOF).
# - suffix: The suffix defined as macro parameter.
# - generated: The code text generated by the macro.
my $output = [];



######################################### INPUT HANDLING #########################################

sub showHelp($)
{
	my ($errmsg) = @_;

	print(STDERR "${errmsg}\n\n") if ($errmsg);

	print <<HELP
$appname-$appversion

Replace the main XENUM4_DECLARE() and XENUM4_DEFINE() macros with the content they generate,
so you can inspect what is generated, and run automated code documentation generation on the
result.

Usage:
$filename [options]

General options:
    -c, --compiler BINARYNAME Name (or path) to compiler to use for preprocessing. If not
                              defined, 'g++' and 'clang' is tried.
    -i, --input FILENAME      Input file to process. Can be a header or source file.
    -o, --output FILENAME     Output file. Optional, writes to stdout if not defined.

HELP
;
	exit 1;
}


sub show_version()
{
	print("$appname-$appversion\n");
	exit(1);
}


sub parseArgs()
{
	my ($argc, $aidx, $arg, $val);

	$argc = @ARGV;

	showHelp("") unless ($argc > 0);
	for ($aidx=0; $aidx<$argc; $aidx++) {
		$arg = $ARGV[$aidx];
		if ($arg =~ /^(?:-c|--compiler)$/) {
			showHelp("Error: Value missing after $arg") if ($aidx == ($argc-1));
			$compiler = $ARGV[++$aidx];
			next;
		}
		if ($arg =~ /^(?:-i|--input)$/) {
			showHelp("Error: Value missing after $arg") if ($aidx == ($argc-1));
			$inputFileName = $ARGV[++$aidx];
			next;
		}
		if ($arg =~ /^(?:-o|--output)$/) {
			showHelp("Error: Value missing after $arg") if ($aidx == ($argc-1));
			$outputFileName = $ARGV[++$aidx];
			next;
		}

		showHelp("error: unknown argument '$arg'");
	}

	if ($inputFileName eq "") {
		showHelp("Error: Input filename missing (-i).");
	}
}


######################################### RAW INPUT FILE #########################################

sub createOutputPart($$$)
{
	my ($inputText, $macro, $suffix) = @_;
print("createOutputPart() macro='${macro}' suffix='${suffix}'\n");
	my $outputPart = {
		inputText => $inputText,
		macro => $macro,
		suffix => $suffix,
		generated => "",
	};
	push(@{$output}, $outputPart);
	return $outputPart;
}


sub parseRawInput()
{
	my ($rawInput, $preInput, $nextInput, $macro, $suffix);
	local $/ = undef;
	open(RAWINPUT, "<${inputFileName}") || die("ERROR: ".
						   "Could not open input file '${inputFileName}'.\n");
	print("parseRawInput() ... \n");
	$rawInput = <RAWINPUT>;
	close(RAWINPUT);

	while ($rawInput =~ /(.*)(?:XENUM4_(DECLARE|DEFINE))(.*)/o) {
		($preInput, $macro, $nextInput) = ($1, $2, $3);
		if ($nextInput =~ /^\s*\(\s*([^\s]+)\s*\)(.*)/) {
			($suffix, $rawInput) = ($1, $2);
		}
		else {
			die("ERROR: Could not parse suffix parameter: ${nextInput}\n");
		}
		createOutputPart($preInput, lc($macro), $suffix);
	}

	if (@{$output} != 0) {
		$doPreProcess = 1;
	}
	if ($rawInput ne "") {
		createOutputPart($rawInput, "", "");
	}
}




############################################# main() #############################################
sub main()
{
	parseArgs();
	parseRawInput();
# FIXME:
# - Construct compiler command line.
# - Run preprocessing.
# - Parse generated code from preprocessed output, store blocks in a map by suffix.
# - Iterate $output: Set ->generated in each output part.
# - Write output (file/stdout).
}


main();
